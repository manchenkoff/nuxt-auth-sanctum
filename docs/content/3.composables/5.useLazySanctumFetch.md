---
title: useLazySanctumFetch
description: How to use useLazySanctumFetch to fetch data from Laravel API
navigation:
  icon: i-lucide-parentheses
---

## Usage

Besides `useSanctumClient` you can directly send a request by using a module-specific 
version of fetch composable - `useLazySanctumFetch`.

This composable implements a similar interface to `useFetch`/`useAsyncData`, 
so you can check more details [here](https://nuxt.com/docs/api/composables/use-fetch).

Composable accepts 4 arguments:
- endpoint URL to call
- `SanctumFetchOptions` to pass to the [Sanctum client](/composables/usesanctumclient) (`ofetch`)
- `AsyncDataOptions` to pass to `useAsyncData` under the hood
- request `key` for reactivity and sharing state (optional)

::warning
Keep in mind that some properties of `FetchOptions` are not available in `SanctumFetchOptions` due to misbehaviour 
on override by the user. You should set them only by using 
the [module configuration](/usage/configuration) or [Nuxt hooks](/hooks/sanctum-request). Unavailable properties:
- `baseUrl`
- `credentials`, `redirect`, `retry`
- `onRequest`, `onRequestError`
- `onResponse`, `onResponseError`
::

```typescript
const { data, status, error, refresh } = await useLazySanctumFetch('/api/users')

// or

const { data, status, error, refresh } = await useLazySanctumFetch(
  '/api/users',
  {
    method: 'GET',
    query: { page: 1 }
  },
  {
    default() { 
      return { 
        data: [], 
        meta: {
          total: 0, 
          per_page: 0 
        } 
      }
    }
  },
  'my-request-key',
)
```

You can also use type casting to work with the response as an interface:

```typescript
interface MyResponse {
  name: string
}

const { data } = await useLazySanctumFetch<MyResponse>('/api/endpoint')

const name = data.value.name // augmented by MyResponse interface
```

## Reactive parameters

If you want to use reactive parameters for the query, you should pass `SanctumFetchOptions` as a function 
to recalculate values on a new request

```typescript
const page = ref(1)

const { data } = await useLazySanctumFetch(
    '/api/posts',
    () => ({ 
        params: {
            page: page.value, // reactive value
        } 
    }),
    {
        watch: [page],
    },
)
```

Once `page` value changes, the data will be refetched automatically, and the new value will be passed in query parameters.

## Reactive URL/key

You can also provide a reactive fetch `key` in order to trigger request once it changes:

```typescript
const currentUser = ref(1)
const userUrl = computed(() => `/api/users/${currentUser}`)

const { data } = await useSanctumFetch(
    userUrl,
    {
        // request params if needed
    },
    {
        // async params if needed
    },
    userUrl
)
```

If `currentUser` value changed, then the request will be made automatically and 
the URL will contain reflected reactive value.

::warning
Please, keep in mind, `useSanctumFetch` uses `useAsyncData` composable behind the scenes,
so the behavior is different from `useFetch`.
::
